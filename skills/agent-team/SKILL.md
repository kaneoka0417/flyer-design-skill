---
name: agent-team
description: Claude Code Agent Team運用スキル。並列マルチエージェントでの開発タスク分割・実行・品質管理。Worktree隔離・品質ゲートHooks・コスト最適化を含む包括的ガイド。
triggers:
  - "チームで"
  - "並列で"
  - "agent team"
  - "エージェントチーム"
  - "マルチエージェント"
  - "swarm"
---

# Agent Team 運用スキル

Claude Code公式のAgent Team機能を使い、並列マルチエージェントで開発タスクを高速・高品質に実行するためのスキル。

---

## 1. いつAgent Teamを使うか

### 判断フローチャート

```
タスクを見る
  ├─ 並列化のメリットがあるか？
  │   ├─ No → 通常セッション or サブエージェント（Task tool）
  │   └─ Yes → 次へ
  ├─ ワーカー同士が通信する必要があるか？
  │   ├─ No → サブエージェント（Task tool）で十分
  │   └─ Yes → Agent Team を使う
  └─ タスクはファイル非交差に分割可能か？
      ├─ No → 通常セッションで順次実行
      └─ Yes → Agent Team が最適
```

### Agent Team vs サブエージェント（Task tool）

| 基準       | Agent Team                        | サブエージェント   |
| ---------- | --------------------------------- | ------------------ |
| 通信       | Teammate同士が直接メッセージ可能  | 結果のみ親に返却   |
| コスト     | 3人で約3-4倍                      | 3人で約2倍         |
| 適用場面   | 協調・議論・クロスレイヤー作業    | 独立した集中タスク |
| 共有状態   | 共有タスクリスト + メールボックス | なし               |
| セッション | 各自独立したコンテキスト          | 親のコンテキスト内 |

### Agent Teamが有効なタスク

| タスク種類             | 推奨チーム規模 | 理由                                                 |
| ---------------------- | -------------- | ---------------------------------------------------- |
| PRレビュー・調査       | 3人            | セキュリティ/パフォーマンス/アーキテクチャで視点分担 |
| 新機能開発             | 3-4人          | フロント/バック/テスト+コーディネーター              |
| バグ調査               | 2-3人          | 競合仮説を並列検証                                   |
| コードマイグレーション | 4-5人          | ファイル分割が容易で並列化メリット大                 |
| 大規模リファクタリング | 3-5人          | モジュール単位で分担                                 |

### Agent Teamを使うべきでないタスク

- 厳密な順次依存タスク（A完了→B→C）
- 3ファイル以下の小規模変更
- 単純なバグ修正（1箇所の修正）

---

## 2. チーム構成

### モデル構成（必須）

| 役割                    | モデル | 理由                                           |
| ----------------------- | ------ | ---------------------------------------------- |
| **Lead（リーダー）**    | Opus   | 戦略判断・タスク分解・結果統合                 |
| **Teammates（実装者）** | Sonnet | 明確に定義された実装に十分。コスト約40-50%削減 |

**Spawn時の指示例:**

```
3人のチームを作って、全員Sonnetで。
- Teammate 1: src/components/features/tasks/ のUIコンポーネント
- Teammate 2: src/lib/actions/tasks.ts のServer Actions
- Teammate 3: src/__tests__/ のテスト追加
各自Worktreeを使って作業してください。
```

### 推奨チームサイズ

- **最小**: 2人（ペアデバッグ、小規模レビュー）
- **推奨**: 3人（最もバランスが良い）
- **最大実用**: 5人（これ以上は調整オーバーヘッドが並列化メリットを上回る）
- **タスク粒度**: チームメイト1人あたり 5-6タスク が最適

---

## 3. Spawn Promptテンプレート

チームメイトはリーダーの会話履歴を引き継がない。CLAUDE.md・Skills・MCPは自動読み込みされるが、**Spawn Promptが唯一のコンテキスト伝達手段**。

### テンプレート構造

```
What（何をやるか）→ Where（どこで）→ Focus（注目点）→ Deliverable（成果物）
```

### 実装タスク用テンプレート

```
あなたはワーカーエージェントです。自分のチームやサブエージェントを作成しないでください。

## タスク
[具体的な達成目標を1文で]

## 対象ファイル
- [パス1] — [変更内容]
- [パス2] — [変更内容]

## 注目点
1. [技術的な注意点1]
2. [技術的な注意点2]

## 制約
- CLAUDE.md のルールに従う
- 日付処理は getTodayDate() を使用
- Worktreeで隔離して作業する

## 成果物
- [完了条件1]
- [完了条件2]
- テストが通ること
```

### レビュータスク用テンプレート

```
あなたはレビューワーカーです。自分のチームやサブエージェントを作成しないでください。

## レビュー対象
[パス or PR番号]

## レビュー観点
1. [観点1: セキュリティ / パフォーマンス / アーキテクチャ]
2. [具体的な確認項目]

## 成果物
問題の深刻度（High/Medium/Low）別リスト
```

### WORKERプリアンブル（必須）

各Spawn Promptの冒頭に必ず含める:

```
あなたはワーカーエージェントです。自分のチームやサブエージェントを作成しないでください。
```

これにより、再帰的なエージェント生成（エージェントが自分のエージェントを生成しようとする問題）を防止。

---

## 4. タスク分割ルール

### 原則: ファイル非交差（file-disjoint）

各チームメイトが異なるファイルセットを担当するようにタスクを分割する。

```
Teammate A: app/src/components/features/tasks/   のみ
Teammate B: app/src/lib/actions/tasks.ts          のみ
Teammate C: app/src/__tests__/tasks/              のみ
```

### 依存関係ウェーブ方式

依存関係に基づいて実行ウェーブを構造化:

```
Wave 1（並列）: 依存なしのタスクを全並列実行
  ├─ Teammate A: マイグレーション作成
  ├─ Teammate B: ユーティリティ関数実装
  └─ Teammate C: テスト作成

Wave 2（Wave 1完了後）: 依存タスク
  ├─ Teammate A: Server Actions実装（Wave 1の型定義に依存）
  └─ Teammate B: UIコンポーネント実装（Wave 1のユーティリティに依存）
```

### 共有ファイルの管理

CLAUDE.mdに明示された共有ファイル（types, queries, migrations）は、**リーダーが編集順序を管理**する。チームメイトが直接編集する場合は、リーダーへのメッセージで調整を依頼。

### Worktree隔離（推奨）

各チームメイトにWorktreeでの作業を指示:

```
各自Worktreeを使って作業してください。
完了後はgitの通常のマージフローで統合します。
```

**Worktreeのメリット:**

- ファイルレベルの完全隔離（コンテキスト汚染なし）
- エージェントAがファイルを読んでいる間にBが書き換える問題が根本解消
- 変更なしのWorktreeは自動削除

---

## 5. 品質ゲート

### TaskCompleted Hook

タスク完了マーク時に自動実行。テスト+lint が通らなければ完了を拒否。

- 設定: `.claude/hooks/task-completed.sh`
- トリガー: チームメイトがタスクを完了とマークしたとき
- exit 0 = 完了承認 / exit 2 = 完了拒否（フィードバック送信）

### TeammateIdle Hook

チームメイトがアイドルになる直前に実行。型エラーが残っていれば作業続行を指示。

- 設定: `.claude/hooks/teammate-idle.sh`
- トリガー: チームメイトが全タスク完了後にアイドルになろうとするとき
- exit 0 = アイドル許可 / exit 2 = 作業続行指示

---

## 6. よくある失敗パターンと回避法

| #   | 失敗パターン                 | 原因                             | 回避法                                          |
| --- | ---------------------------- | -------------------------------- | ----------------------------------------------- |
| 1   | **同一ファイル競合**         | 複数Teammateが同じファイルを編集 | Worktree隔離 + ディレクトリ単位のオーナーシップ |
| 2   | **リーダーが実装してしまう** | Delegate Modeを使っていない      | `Shift+Tab` で Delegate Mode に切替             |
| 3   | **パーミッション待ち停止**   | チームメイトが承認待ち           | settings.jsonで事前に許可リスト設定             |
| 4   | **インターフェース不整合**   | 型定義やAPIスキーマが合わない    | 事前にtypes/を固定 or リーダーが一括管理        |
| 5   | **タスク完了マーク忘れ**     | 依存タスクがブロック             | TaskCompleted Hookで自動検証                    |
| 6   | **エラーカスケード**         | 初期ミスが後続で増幅             | 計画フェーズでの徹底レビュー                    |
| 7   | **コンテキスト汚染**         | 同じ作業ディレクトリを共有       | Worktreeで完全隔離                              |
| 8   | **スコープ肥大**             | 1エージェントに多すぎる役割      | 狭いスコープと明確な責務                        |
| 9   | **broadcastの乱用**          | 全員への送信でコスト爆発         | write（個別メッセージ）を優先                   |
| 10  | **順次依存タスクでの使用**   | 並列化メリットなし               | シングルセッション or サブエージェントを使う    |

---

## 7. コスト最適化

### 5つのコスト削減テクニック

1. **Lead=Opus / Teammates=Sonnet** — 実装レベルの品質差は無視できるがコスト差は甚大
2. **計画フェーズを先に** — Plan Mode（安い）で計画 → 承認後にチーム実行（高い）
3. **broadcastを控える** — 全員への送信はチームサイズに比例してコスト増。writeを優先
4. **CLAUDE.mdの整備** — 3人が明確なCLAUDE.mdを読む方が、3人がコードベースを独自探索するよりはるかに安い
5. **小チーム連続フェーズ** — 1つの巨大チームより、小チームの連続フェーズの方が無駄が少ない

### コスト見積もり

| 方式                         | トークン消費（目安）          |
| ---------------------------- | ----------------------------- |
| シングルセッション           | 約200kトークン                |
| サブエージェント3人          | 約440kトークン（2.2倍）       |
| Agent Team 3人               | 約600-800kトークン（3-4倍）   |
| Agent Team 3人（Sonnet混成） | 約400-500kトークン（2-2.5倍） |

---

## 8. 実行フロー

### Phase 1: 計画（Plan Mode）

```
1. EnterPlanMode でタスクを分析
2. モジュール境界に基づいてタスクを分割
3. 依存関係ウェーブを設計
4. ExitPlanMode でユーザー承認
```

### Phase 2: チーム作成

```
3人のチームを作成。全員Sonnetで、Worktreeを使って作業してください。

Teammate 1「フロントエンド」:
[Spawn Promptテンプレートに従った詳細指示]

Teammate 2「バックエンド」:
[Spawn Promptテンプレートに従った詳細指示]

Teammate 3「テスト」:
[Spawn Promptテンプレートに従った詳細指示]
```

### Phase 3: 監視・調整

- 各Teammateの進捗をモニタリング
- 共有ファイルの編集順序を管理
- 問題発生時は個別メッセージ（broadcast不使用）

### Phase 4: 統合・検証

```
1. 全Teammateの変更をマージ
2. npm run test:run でテスト確認
3. npm run build でビルド確認
4. 型チェック（npx tsc --noEmit）
```

---

## 9. Orbitプロジェクト固有設定

### 環境変数

settings.jsonに設定済み:

```json
{
  "env": { "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1" },
  "teammateMode": "tmux"
}
```

### Hooks

settings.jsonに登録済み:

- `TaskCompleted` → `.claude/hooks/task-completed.sh`（テスト+lint強制）
- `TeammateIdle` → `.claude/hooks/teammate-idle.sh`（型エラー検出）

### モジュール境界

CLAUDE.mdに記載。Agent Team時の分担基準:

| モジュール       | パス                           |
| ---------------- | ------------------------------ |
| ページ           | `app/src/app/(auth)/`          |
| 機能UI           | `app/src/components/features/` |
| Server Actions   | `app/src/lib/actions/`         |
| ユーティリティ   | `app/src/lib/utils/`           |
| 型定義           | `app/src/types/`               |
| マイグレーション | `supabase/migrations/`         |

### 共有ファイル（coordinate before editing）

- `app/src/types/*.ts`
- `app/src/lib/supabase/queries.ts`
- `supabase/migrations/`
